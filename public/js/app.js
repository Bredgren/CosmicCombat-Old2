// Generated by CoffeeScript 1.6.2
(function() {
  var AttractionDemo, BalloonDemo, BoundsDemo, ChainDemo, ClothDemo, CollisionDemo, DebugDraw, Demo, H, Renderer, W, WebGLRenderer, b2Collision, b2Common, b2Contacts, b2Controllers, b2Dynamics, b2Joints, b2Math, b2Shapes, main, settings, _ref, _ref1, _ref2, _ref3, _ref4, _ref5,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  settings = {
    DEBUG: true,
    FULL_SCREEN: true,
    WIDTH: 700,
    HEIGHT: 500
  };

  b2Common = Box2D.Common;

  b2Math = Box2D.Common.Math;

  b2Collision = Box2D.Collision;

  b2Shapes = Box2D.Collision.Shapes;

  b2Dynamics = Box2D.Dynamics;

  b2Contacts = Box2D.Dynamics.Contacts;

  b2Controllers = Box2D.Dynamics.Controllers;

  b2Joints = Box2D.Dynamics.Joints;

  DebugDraw = (function(_super) {
    __extends(DebugDraw, _super);

    function DebugDraw() {
      this._line_width = 1;
      this._alpha = 0.5;
      this._fill_alpha = 0.5;
      this._scale = 1.0;
      this.m_sprite = {
        graphics: {
          clear: function() {}
        }
      };
    }

    DebugDraw.prototype.SetSprite = function(_graphics) {
      this._graphics = _graphics;
    };

    DebugDraw.prototype.GetSprite = function() {
      return this._graphics;
    };

    DebugDraw.prototype.DrawCircle = function(center, radius, color) {
      this._graphics.alpha = this._alpha;
      this._graphics.lineStyle(this._line_width, color.color);
      return this._graphics.drawCircle(center.x * this._scale, center.y * this._scale, radius * this._scale);
    };

    DebugDraw.prototype.DrawPolygon = function(vertices, vertexCount, color) {
      var v, v0, _i, _len, _ref;

      this._graphics.lineStyle(this._line_width, color.color);
      this._graphics.alpha = this._alpha;
      v0 = vertices[0];
      this._graphics.moveTo(v0.x * this._scale, v0.y * this._scale);
      _ref = vertices.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        this._graphics.lineTo(v.x * this._scale, v.y * this._scale);
      }
      return this._graphics.lineTo(v0.x * this._scale, v0.y * this._scale);
    };

    DebugDraw.prototype.DrawSegment = function(p1, p2, color) {
      this._graphics.lineStyle(this._line_width, color.color);
      this._graphics.alpha = this._alpha;
      this._graphics.moveTo(p1.x * this._scale, p1.y * this._scale);
      return this._graphics.lineTo(p2.x * this._scale, p2.y * this._scale);
    };

    DebugDraw.prototype.DrawSolidCircle = function(center, radius, axis, color) {
      var edge;

      this._graphics.beginFill(color.color);
      this._graphics.fillAlpha = this._fill_alpha;
      this.DrawCircle(center, radius, color);
      this._graphics.endFill();
      axis.Normalize();
      axis.Multiply(radius);
      edge = center.Copy();
      edge.Add(axis);
      return this.DrawSegment(center, edge, color);
    };

    DebugDraw.prototype.DrawSolidPolygon = function(vertices, vertexCount, color) {
      this._graphics.beginFill(color.color);
      this._graphics.fillAlpha = this._fill_alpha;
      this.DrawPolygon(vertices, vertexCount, color);
      return this._graphics.endFill();
    };

    DebugDraw.prototype.GetAlpha = function() {
      return this._alpha;
    };

    DebugDraw.prototype.GetDrawScale = function() {
      return this._scale;
    };

    DebugDraw.prototype.GetFillAlpha = function() {
      return this._fill_alpha;
    };

    DebugDraw.prototype.GetLineThickness = function() {
      return this._line_width;
    };

    DebugDraw.prototype.SetAlpha = function(_alpha) {
      this._alpha = _alpha;
    };

    DebugDraw.prototype.SetDrawScale = function(_scale) {
      this._scale = _scale;
    };

    DebugDraw.prototype.SetLineThickness = function(_line_width) {
      this._line_width = _line_width;
    };

    return DebugDraw;

  })(b2Dynamics.b2DebugDraw);

  $(function() {
    var DOM_LOADED, a, queue;

    DOM_LOADED = true;
    a = new CollisionDemo();
    a.init($('body')[0]);
    queue = function() {
      a.step();
      return window.requestAnimationFrame(queue);
    };
    return queue();
  });

  W = 0;

  H = 0;

  main = function() {
    var black, blurHandler, body, bodyDef, canvas, clear, clickHandler, container, debugDraw, draw, event_catcher, fixDef, focusHandler, graphics, i, keyDownListener, main_loop, mouseDownHandler, mouseMoveHandler, mouseOutHandler, mouseUpHandler, mouseWheelHandler, onBeforeUnload, onResize, queue, renderer, s, stage, update, world, _i;

    W = settings.FULL_SCREEN ? window.innerWidth : settings.WIDTH;
    H = settings.FULL_SCREEN ? window.innerHeight : settings.HEIGHT;
    body = $('body');
    container = $('<div>');
    body.append(container);
    black = 0x000000;
    stage = new PIXI.Stage(black);
    renderer = PIXI.autoDetectRenderer(W, H);
    container.append(renderer.view);
    canvas = $('canvas')[0];
    graphics = new PIXI.Graphics();
    stage.addChild(graphics);
    world = new b2Dynamics.b2World(new b2Math.b2Vec2(0, 10), true);
    fixDef = new b2Dynamics.b2FixtureDef();
    fixDef.density = 1.0;
    fixDef.friction = 0.5;
    fixDef.restitution = 0.2;
    bodyDef = new b2Dynamics.b2BodyDef();
    bodyDef.type = b2Dynamics.b2Body.b2_staticBody;
    bodyDef.position.x = W / 2 / 30;
    bodyDef.position.y = 13;
    fixDef.shape = new b2Shapes.b2PolygonShape();
    s = fixDef.shape;
    s.SetAsBox(10, 1);
    world.CreateBody(bodyDef).CreateFixture(fixDef);
    bodyDef.type = b2Dynamics.b2Body.b2_dynamicBody;
    for (i = _i = 0; _i <= 10; i = ++_i) {
      if (Math.random() > 0.5) {
        fixDef.shape = new b2Shapes.b2PolygonShape();
        fixDef.shape.SetAsBox(Math.random() + 0.1, Math.random() + 0.1);
      } else {
        fixDef.shape = new b2Collision.Shapes.b2CircleShape(Math.random() + 0.1);
      }
      bodyDef.position.x = Math.random() * 10 + W / 2 / 30 - 5;
      bodyDef.position.y = Math.random() * 10;
      world.CreateBody(bodyDef).CreateFixture(fixDef);
    }
    if (settings.DEBUG) {
      debugDraw = new DebugDraw();
      debugDraw.SetSprite(graphics);
      debugDraw.SetDrawScale(30.0);
      debugDraw.SetFillAlpha(0.3);
      debugDraw.SetLineThickness(1.0);
      debugDraw.SetFlags(b2Dynamics.b2DebugDraw.e_shapeBit | b2Dynamics.b2DebugDraw.e_jointBit);
      world.SetDebugDraw(debugDraw);
    }
    onResize = function() {
      return console.log("resize");
    };
    keyDownListener = function(e) {
      return console.log("key:", e.keyCode);
    };
    onBeforeUnload = function(e) {
      return console.log("leaving");
    };
    mouseMoveHandler = function(e) {
      var x, y;

      x = e.clientX;
      y = e.clientY;
      return console.log("mouse:", x, y);
    };
    clickHandler = function(e) {
      var x, y;

      x = e.clientX;
      y = e.clientY;
      return console.log("click:", x, y);
    };
    mouseDownHandler = function(e) {
      return console.log("mouse down");
    };
    mouseUpHandler = function(e) {
      return console.log("mouse up");
    };
    mouseOutHandler = function(e) {
      return console.log("mouse out");
    };
    mouseWheelHandler = function(e) {
      var delta;

      delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));
      return console.log("mouse wheel: ", delta);
    };
    focusHandler = function(e) {
      return console.log("focus");
    };
    blurHandler = function(e) {
      return console.log("blur");
    };
    event_catcher = canvas;
    window.onresize = onResize;
    document.body.addEventListener('keydown', keyDownListener, false);
    window.onbeforeunload = onBeforeUnload;
    event_catcher.addEventListener('mousemove', mouseMoveHandler, false);
    event_catcher.addEventListener('click', clickHandler, false);
    event_catcher.addEventListener('mousedown', mouseDownHandler, false);
    event_catcher.addEventListener('mouseup', mouseUpHandler, false);
    event_catcher.addEventListener('mouseout', mouseOutHandler, false);
    event_catcher.addEventListener('DOMMouseScroll', mouseWheelHandler, false);
    event_catcher.addEventListener('mousewheel', mouseWheelHandler, false);
    event_catcher.addEventListener('focus', focusHandler, false);
    event_catcher.addEventListener('blur', blurHandler, false);
    main_loop = function() {
      update();
      clear();
      draw();
      return queue();
    };
    update = function() {
      world.Step(1 / 60, 10, 10);
      return world.ClearForces();
    };
    clear = function() {
      return graphics.clear();
    };
    draw = function() {
      if (settings.DEBUG) {
        world.DrawDebugData();
      }
      return renderer.render(stage);
    };
    queue = function() {
      return window.requestAnimationFrame(main_loop);
    };
    return main_loop();
  };

  /* Base Renderer
  */


  Renderer = (function() {
    function Renderer() {
      this.setSize = __bind(this.setSize, this);      this.width = 0;
      this.height = 0;
      this.renderParticles = true;
      this.renderSprings = true;
      this.renderMouse = true;
      this.initialized = false;
      this.renderTime = 0;
    }

    Renderer.prototype.init = function(physics) {
      return this.initialized = true;
    };

    Renderer.prototype.render = function(physics) {
      if (!this.initialized) {
        return this.init(physics);
      }
    };

    Renderer.prototype.setSize = function(width, height) {
      this.width = width;
      this.height = height;
    };

    Renderer.prototype.destroy = function() {};

    return Renderer;

  })();

  /* WebGL Renderer
  */


  WebGLRenderer = (function(_super) {
    __extends(WebGLRenderer, _super);

    WebGLRenderer.PARTICLE_VS = '\nuniform vec2 viewport;\nattribute vec3 position;\nattribute float radius;\nattribute vec4 colour;\nvarying vec4 tint;\n\nvoid main() {\n\n    // convert the rectangle from pixels to 0.0 to 1.0\n    vec2 zeroToOne = position.xy / viewport;\n    zeroToOne.y = 1.0 - zeroToOne.y;\n\n    // convert from 0->1 to 0->2\n    vec2 zeroToTwo = zeroToOne * 2.0;\n\n    // convert from 0->2 to -1->+1 (clipspace)\n    vec2 clipSpace = zeroToTwo - 1.0;\n\n    tint = colour;\n\n    gl_Position = vec4(clipSpace, 0, 1);\n    gl_PointSize = radius * 2.0;\n}';

    WebGLRenderer.PARTICLE_FS = '\nprecision mediump float;\n\nuniform sampler2D texture;\nvarying vec4 tint;\n\nvoid main() {\n    gl_FragColor = texture2D(texture, gl_PointCoord) * tint;\n}';

    WebGLRenderer.SPRING_VS = '\nuniform vec2 viewport;\nattribute vec3 position;\n\nvoid main() {\n\n    // convert the rectangle from pixels to 0.0 to 1.0\n    vec2 zeroToOne = position.xy / viewport;\n    zeroToOne.y = 1.0 - zeroToOne.y;\n\n    // convert from 0->1 to 0->2\n    vec2 zeroToTwo = zeroToOne * 2.0;\n\n    // convert from 0->2 to -1->+1 (clipspace)\n    vec2 clipSpace = zeroToTwo - 1.0;\n\n    gl_Position = vec4(clipSpace, 0, 1);\n}';

    WebGLRenderer.SPRING_FS = '\nvoid main() {\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 0.1);\n}';

    function WebGLRenderer(usePointSprites) {
      var error;

      this.usePointSprites = usePointSprites != null ? usePointSprites : true;
      this.setSize = __bind(this.setSize, this);
      WebGLRenderer.__super__.constructor.apply(this, arguments);
      this.particlePositionBuffer = null;
      this.particleRadiusBuffer = null;
      this.particleColourBuffer = null;
      this.particleTexture = null;
      this.particleShader = null;
      this.springPositionBuffer = null;
      this.springShader = null;
      this.canvas = document.createElement('canvas');
      try {
        this.gl = this.canvas.getContext('experimental-webgl');
      } catch (_error) {
        error = _error;
      } finally {
        if (!this.gl) {
          return new CanvasRenderer();
        }
      }
      this.domElement = this.canvas;
    }

    WebGLRenderer.prototype.init = function(physics) {
      WebGLRenderer.__super__.init.call(this, physics);
      this.initShaders();
      this.initBuffers(physics);
      this.particleTexture = this.createParticleTextureData();
      this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE);
      return this.gl.enable(this.gl.BLEND);
    };

    WebGLRenderer.prototype.initShaders = function() {
      this.particleShader = this.createShaderProgram(WebGLRenderer.PARTICLE_VS, WebGLRenderer.PARTICLE_FS);
      this.springShader = this.createShaderProgram(WebGLRenderer.SPRING_VS, WebGLRenderer.SPRING_FS);
      this.particleShader.uniforms = {
        viewport: this.gl.getUniformLocation(this.particleShader, 'viewport')
      };
      this.springShader.uniforms = {
        viewport: this.gl.getUniformLocation(this.springShader, 'viewport')
      };
      this.particleShader.attributes = {
        position: this.gl.getAttribLocation(this.particleShader, 'position'),
        radius: this.gl.getAttribLocation(this.particleShader, 'radius'),
        colour: this.gl.getAttribLocation(this.particleShader, 'colour')
      };
      this.springShader.attributes = {
        position: this.gl.getAttribLocation(this.springShader, 'position')
      };
      return console.log(this.particleShader);
    };

    WebGLRenderer.prototype.initBuffers = function(physics) {
      var a, b, colours, g, particle, r, radii, rgba, _i, _len, _ref;

      colours = [];
      radii = [];
      this.particlePositionBuffer = this.gl.createBuffer();
      this.springPositionBuffer = this.gl.createBuffer();
      this.particleColourBuffer = this.gl.createBuffer();
      this.particleRadiusBuffer = this.gl.createBuffer();
      _ref = physics.particles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        particle = _ref[_i];
        rgba = (particle.colour || '#FFFFFF').match(/[\dA-F]{2}/gi);
        r = (parseInt(rgba[0], 16)) || 255;
        g = (parseInt(rgba[1], 16)) || 255;
        b = (parseInt(rgba[2], 16)) || 255;
        a = (parseInt(rgba[3], 16)) || 255;
        colours.push(r / 255, g / 255, b / 255, a / 255);
        radii.push(particle.radius || 32);
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particleColourBuffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colours), this.gl.STATIC_DRAW);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particleRadiusBuffer);
      return this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(radii), this.gl.STATIC_DRAW);
    };

    WebGLRenderer.prototype.createParticleTextureData = function(size) {
      var canvas, ctx, rad, texture;

      if (size == null) {
        size = 128;
      }
      canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      ctx = canvas.getContext('2d');
      rad = size * 0.5;
      ctx.beginPath();
      ctx.arc(rad, rad, rad, 0, Math.PI * 2, false);
      ctx.closePath();
      ctx.fillStyle = '#FFF';
      ctx.fill();
      texture = this.gl.createTexture();
      this.setupTexture(texture, canvas);
      return texture;
    };

    WebGLRenderer.prototype.loadTexture = function(source) {
      var texture,
        _this = this;

      texture = this.gl.createTexture();
      texture.image = new Image();
      texture.image.onload = function() {
        return _this.setupTexture(texture, texture.image);
      };
      texture.image.src = source;
      return texture;
    };

    WebGLRenderer.prototype.setupTexture = function(texture, data) {
      this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, data);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
      this.gl.generateMipmap(this.gl.TEXTURE_2D);
      this.gl.bindTexture(this.gl.TEXTURE_2D, null);
      return texture;
    };

    WebGLRenderer.prototype.createShaderProgram = function(_vs, _fs) {
      var fs, prog, vs;

      vs = this.gl.createShader(this.gl.VERTEX_SHADER);
      fs = this.gl.createShader(this.gl.FRAGMENT_SHADER);
      this.gl.shaderSource(vs, _vs);
      this.gl.shaderSource(fs, _fs);
      this.gl.compileShader(vs);
      this.gl.compileShader(fs);
      if (!this.gl.getShaderParameter(vs, this.gl.COMPILE_STATUS)) {
        alert(this.gl.getShaderInfoLog(vs));
        null;
      }
      if (!this.gl.getShaderParameter(fs, this.gl.COMPILE_STATUS)) {
        alert(this.gl.getShaderInfoLog(fs));
        null;
      }
      prog = this.gl.createProgram();
      this.gl.attachShader(prog, vs);
      this.gl.attachShader(prog, fs);
      this.gl.linkProgram(prog);
      return prog;
    };

    WebGLRenderer.prototype.setSize = function(width, height) {
      this.width = width;
      this.height = height;
      WebGLRenderer.__super__.setSize.call(this, this.width, this.height);
      this.canvas.width = this.width;
      this.canvas.height = this.height;
      this.gl.viewport(0, 0, this.width, this.height);
      this.gl.useProgram(this.particleShader);
      this.gl.uniform2fv(this.particleShader.uniforms.viewport, new Float32Array([this.width, this.height]));
      this.gl.useProgram(this.springShader);
      return this.gl.uniform2fv(this.springShader.uniforms.viewport, new Float32Array([this.width, this.height]));
    };

    WebGLRenderer.prototype.render = function(physics) {
      var p, s, vertices, _i, _j, _len, _len1, _ref, _ref1;

      WebGLRenderer.__super__.render.apply(this, arguments);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      if (this.renderParticles) {
        vertices = [];
        _ref = physics.particles;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          vertices.push(p.pos.x, p.pos.y, 0.0);
        }
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.particleTexture);
        this.gl.useProgram(this.particleShader);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlePositionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
        this.gl.vertexAttribPointer(this.particleShader.attributes.position, 3, this.gl.FLOAT, false, 0, 0);
        this.gl.enableVertexAttribArray(this.particleShader.attributes.position);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particleColourBuffer);
        this.gl.enableVertexAttribArray(this.particleShader.attributes.colour);
        this.gl.vertexAttribPointer(this.particleShader.attributes.colour, 4, this.gl.FLOAT, false, 0, 0);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particleRadiusBuffer);
        this.gl.enableVertexAttribArray(this.particleShader.attributes.radius);
        this.gl.vertexAttribPointer(this.particleShader.attributes.radius, 1, this.gl.FLOAT, false, 0, 0);
        this.gl.drawArrays(this.gl.POINTS, 0, vertices.length / 3);
      }
      if (this.renderSprings && physics.springs.length > 0) {
        vertices = [];
        _ref1 = physics.springs;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          s = _ref1[_j];
          vertices.push(s.p1.pos.x, s.p1.pos.y, 0.0);
          vertices.push(s.p2.pos.x, s.p2.pos.y, 0.0);
        }
        this.gl.useProgram(this.springShader);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.springPositionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
        this.gl.vertexAttribPointer(this.springShader.attributes.position, 3, this.gl.FLOAT, false, 0, 0);
        this.gl.enableVertexAttribArray(this.springShader.attributes.position);
        return this.gl.drawArrays(this.gl.LINES, 0, vertices.length / 3);
      }
    };

    WebGLRenderer.prototype.destroy = function() {};

    return WebGLRenderer;

  })(Renderer);

  /* Demo
  */


  Demo = (function() {
    Demo.COLOURS = ['DC0048', 'F14646', '4AE6A9', '7CFF3F', '4EC9D9', 'E4272E'];

    function Demo() {
      this.mousemove = __bind(this.mousemove, this);
      this.resize = __bind(this.resize, this);      this.physics = new Physics();
      this.mouse = new Particle();
      this.mouse.fixed = true;
      this.height = window.innerHeight;
      this.width = window.innerWidth;
      this.renderTime = 0;
      this.counter = 0;
    }

    Demo.prototype.setup = function(full) {
      if (full == null) {
        return full = true;
      }
      /* Override and add paticles / springs here
      */

    };

    /* Initialise the demo (override).
    */


    Demo.prototype.init = function(container, renderer) {
      var particle, _i, _len, _ref, _ref1;

      this.container = container;
      this.renderer = renderer != null ? renderer : new WebGLRenderer();
      this.setup(this.renderer.gl != null);
      _ref = this.physics.particles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        particle = _ref[_i];
        if ((_ref1 = particle.colour) == null) {
          particle.colour = Random.item(Demo.COLOURS);
        }
      }
      document.addEventListener('touchmove', this.mousemove, false);
      document.addEventListener('mousemove', this.mousemove, false);
      document.addEventListener('resize', this.resize, false);
      this.container.appendChild(this.renderer.domElement);
      this.renderer.mouse = this.mouse;
      this.renderer.init(this.physics);
      return this.resize();
    };

    /* Handler for window resize event.
    */


    Demo.prototype.resize = function(event) {
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      return this.renderer.setSize(this.width, this.height);
    };

    /* Update loop.
    */


    Demo.prototype.step = function() {
      this.physics.step();
      if ((this.renderer.gl != null) || ++this.counter % 3 === 0) {
        return this.renderer.render(this.physics);
      }
    };

    /* Clean up after yourself.
    */


    Demo.prototype.destroy = function() {
      var error;

      document.removeEventListener('touchmove', this.mousemove, false);
      document.removeEventListener('mousemove', this.mousemove, false);
      document.removeEventListener('resize', this.resize, false);
      try {
        container.removeChild(this.renderer.domElement);
      } catch (_error) {
        error = _error;
      }
      this.renderer.destroy();
      this.physics.destroy();
      this.renderer = null;
      this.physics = null;
      return this.mouse = null;
    };

    /* Handler for window mousemove event.
    */


    Demo.prototype.mousemove = function(event) {
      var touch;

      event.preventDefault();
      if (event.touches && !!event.touches.length) {
        touch = event.touches[0];
        return this.mouse.pos.set(touch.pageX, touch.pageY);
      } else {
        return this.mouse.pos.set(event.clientX, event.clientY);
      }
    };

    return Demo;

  })();

  AttractionDemo = (function(_super) {
    __extends(AttractionDemo, _super);

    function AttractionDemo() {
      _ref = AttractionDemo.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    AttractionDemo.prototype.setup = function(full) {
      var attraction, bounds, i, max, min, p, repulsion, _i, _results;

      if (full == null) {
        full = true;
      }
      AttractionDemo.__super__.setup.call(this, full);
      min = new Vector(0.0, 0.0);
      max = new Vector(this.width, this.height);
      bounds = new EdgeBounce(min, max);
      this.physics.integrator = new Verlet();
      attraction = new Attraction(this.mouse.pos, 1200, 1200);
      repulsion = new Attraction(this.mouse.pos, 200, -2000);
      max = full ? 400 : 200;
      _results = [];
      for (i = _i = 0; 0 <= max ? _i <= max : _i >= max; i = 0 <= max ? ++_i : --_i) {
        p = new Particle(Random(0.1, 3.0));
        p.setRadius(p.mass * 4);
        p.moveTo(new Vector(Random(this.width), Random(this.height)));
        p.behaviours.push(attraction);
        p.behaviours.push(repulsion);
        p.behaviours.push(bounds);
        _results.push(this.physics.particles.push(p));
      }
      return _results;
    };

    return AttractionDemo;

  })(Demo);

  ClothDemo = (function(_super) {
    __extends(ClothDemo, _super);

    function ClothDemo() {
      _ref1 = ClothDemo.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    ClothDemo.prototype.setup = function(full) {
      var cell, cols, p, rows, s, size, stiffness, sx, sy, x, y, _i, _j;

      if (full == null) {
        full = true;
      }
      ClothDemo.__super__.setup.apply(this, arguments);
      this.renderer.renderParticles = false;
      this.physics.integrator = new Verlet();
      this.physics.timestep = 1.0 / 200;
      this.mouse.setMass(10);
      this.gravity = new ConstantForce(new Vector(0.0, 80.0));
      this.physics.behaviours.push(this.gravity);
      stiffness = 0.5;
      size = full ? 8 : 10;
      rows = full ? 30 : 25;
      cols = full ? 55 : 40;
      cell = [];
      sx = this.width * 0.5 - cols * size * 0.5;
      sy = this.height * 0.5 - rows * size * 0.5;
      for (x = _i = 0; 0 <= cols ? _i <= cols : _i >= cols; x = 0 <= cols ? ++_i : --_i) {
        cell[x] = [];
        for (y = _j = 0; 0 <= rows ? _j <= rows : _j >= rows; y = 0 <= rows ? ++_j : --_j) {
          p = new Particle(0.1);
          p.fixed = y === 0;
          p.moveTo(new Vector(sx + x * size, sy + y * size));
          if (x > 0) {
            s = new Spring(p, cell[x - 1][y], size, stiffness);
            this.physics.springs.push(s);
          }
          if (y > 0) {
            s = new Spring(p, cell[x][y - 1], size, stiffness);
            this.physics.springs.push(s);
          }
          this.physics.particles.push(p);
          cell[x][y] = p;
        }
      }
      p = cell[Math.floor(cols / 2)][Math.floor(rows / 2)];
      s = new Spring(this.mouse, p, 10, 1.0);
      this.physics.springs.push(s);
      cell[0][0].fixed = true;
      return cell[cols - 1][0].fixed = true;
    };

    ClothDemo.prototype.step = function() {
      ClothDemo.__super__.step.apply(this, arguments);
      return this.gravity.force.x = 50 * Math.sin(new Date().getTime() * 0.0005);
    };

    return ClothDemo;

  })(Demo);

  /* BalloonDemo
  */


  BalloonDemo = (function(_super) {
    __extends(BalloonDemo, _super);

    function BalloonDemo() {
      _ref2 = BalloonDemo.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    BalloonDemo.prototype.setup = function(full) {
      var attraction, i, max, p, s, _i, _results;

      if (full == null) {
        full = true;
      }
      BalloonDemo.__super__.setup.apply(this, arguments);
      this.physics.integrator = new ImprovedEuler();
      attraction = new Attraction(this.mouse.pos);
      max = full ? 400 : 200;
      _results = [];
      for (i = _i = 0; 0 <= max ? _i <= max : _i >= max; i = 0 <= max ? ++_i : --_i) {
        p = new Particle(Random(0.25, 4.0));
        p.setRadius(p.mass * 8);
        p.behaviours.push(new Wander(0.2));
        p.behaviours.push(attraction);
        p.moveTo(new Vector(Random(this.width), Random(this.height)));
        s = new Spring(this.mouse, p, Random(30, 300), 1.0);
        this.physics.particles.push(p);
        _results.push(this.physics.springs.push(s));
      }
      return _results;
    };

    return BalloonDemo;

  })(Demo);

  /* BoundsDemo
  */


  BoundsDemo = (function(_super) {
    __extends(BoundsDemo, _super);

    function BoundsDemo() {
      _ref3 = BoundsDemo.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    BoundsDemo.prototype.setup = function() {
      var edge, i, max, min, p, _i, _results;

      BoundsDemo.__super__.setup.apply(this, arguments);
      min = new Vector(0.0, 0.0);
      max = new Vector(this.width, this.height);
      edge = new EdgeWrap(min, max);
      _results = [];
      for (i = _i = 0; _i <= 200; i = ++_i) {
        p = new Particle(Random(0.5, 4.0));
        p.setRadius(p.mass * 5);
        p.moveTo(new Vector(Random(this.width), Random(this.height)));
        p.behaviours.push(new Wander(0.2, 120, Random(1.0, 2.0)));
        p.behaviours.push(edge);
        _results.push(this.physics.particles.push(p));
      }
      return _results;
    };

    return BoundsDemo;

  })(Demo);

  ChainDemo = (function(_super) {
    __extends(ChainDemo, _super);

    function ChainDemo() {
      _ref4 = ChainDemo.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    ChainDemo.prototype.setup = function(full) {
      var center, edge, gap, i, max, min, op, p, s, wander, _i;

      if (full == null) {
        full = true;
      }
      ChainDemo.__super__.setup.apply(this, arguments);
      this.stiffness = 1.0;
      this.spacing = 2.0;
      this.physics.integrator = new Verlet();
      this.physics.viscosity = 0.0001;
      this.mouse.setMass(1000);
      gap = 50.0;
      min = new Vector(-gap, -gap);
      max = new Vector(this.width + gap, this.height + gap);
      edge = new EdgeBounce(min, max);
      center = new Vector(this.width * 0.5, this.height * 0.5);
      wander = new Wander(0.05, 100.0, 80.0);
      max = full ? 2000 : 600;
      for (i = _i = 0; 0 <= max ? _i <= max : _i >= max; i = 0 <= max ? ++_i : --_i) {
        p = new Particle(6.0);
        p.colour = '#FFFFFF';
        p.moveTo(center);
        p.setRadius(1.0);
        p.behaviours.push(wander);
        p.behaviours.push(edge);
        this.physics.particles.push(p);
        if (typeof op !== "undefined" && op !== null) {
          s = new Spring(op, p, this.spacing, this.stiffness);
        } else {
          s = new Spring(this.mouse, p, this.spacing, this.stiffness);
        }
        this.physics.springs.push(s);
        op = p;
      }
      return this.physics.springs.push(new Spring(this.mouse, p, this.spacing, this.stiffness));
    };

    return ChainDemo;

  })(Demo);

  /* CollisionDemo
  */


  CollisionDemo = (function(_super) {
    __extends(CollisionDemo, _super);

    function CollisionDemo() {
      this.onCollision = __bind(this.onCollision, this);      _ref5 = CollisionDemo.__super__.constructor.apply(this, arguments);
      return _ref5;
    }

    CollisionDemo.prototype.setup = function(full) {
      var attraction, bounds, collide, i, max, min, p, prob, s, _i, _results;

      if (full == null) {
        full = true;
      }
      CollisionDemo.__super__.setup.apply(this, arguments);
      this.physics.integrator = new Verlet();
      min = new Vector(0.0, 0.0);
      max = new Vector(this.width, this.height);
      bounds = new EdgeBounce(min, max);
      collide = new Collision;
      attraction = new Attraction(this.mouse.pos, 2000, 1400);
      max = full ? 350 : 150;
      prob = full ? 0.35 : 0.5;
      _results = [];
      for (i = _i = 0; 0 <= max ? _i <= max : _i >= max; i = 0 <= max ? ++_i : --_i) {
        p = new Particle(Random(0.5, 4.0));
        p.setRadius(p.mass * 4);
        p.moveTo(new Vector(Random(this.width), Random(this.height)));
        if (Random.bool(prob)) {
          s = new Spring(this.mouse, p, Random(120, 180), 0.8);
          this.physics.springs.push(s);
        } else {
          p.behaviours.push(attraction);
        }
        collide.pool.push(p);
        p.behaviours.push(collide);
        p.behaviours.push(bounds);
        _results.push(this.physics.particles.push(p));
      }
      return _results;
    };

    CollisionDemo.prototype.onCollision = function(p1, p2) {};

    return CollisionDemo;

  })(Demo);

}).call(this);
