// Generated by CoffeeScript 1.6.2
(function() {
  var DebugDraw, H, ParticleSystem, W, b2Collision, b2Common, b2Contacts, b2Controllers, b2Dynamics, b2Joints, b2Math, b2Shapes, main, settings,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  settings = {
    DEBUG: true,
    FULL_SCREEN: true,
    WIDTH: 700,
    HEIGHT: 500
  };

  b2Common = Box2D.Common;

  b2Math = Box2D.Common.Math;

  b2Collision = Box2D.Collision;

  b2Shapes = Box2D.Collision.Shapes;

  b2Dynamics = Box2D.Dynamics;

  b2Contacts = Box2D.Dynamics.Contacts;

  b2Controllers = Box2D.Dynamics.Controllers;

  b2Joints = Box2D.Dynamics.Joints;

  DebugDraw = (function(_super) {
    __extends(DebugDraw, _super);

    function DebugDraw() {
      this._line_width = 1;
      this._alpha = 0.5;
      this._fill_alpha = 0.5;
      this._scale = 1.0;
      this.m_sprite = {
        graphics: {
          clear: function() {}
        }
      };
    }

    DebugDraw.prototype.SetSprite = function(_graphics) {
      this._graphics = _graphics;
    };

    DebugDraw.prototype.GetSprite = function() {
      return this._graphics;
    };

    DebugDraw.prototype.DrawCircle = function(center, radius, color) {
      this._graphics.alpha = this._alpha;
      this._graphics.lineStyle(this._line_width, color.color);
      return this._graphics.drawCircle(center.x * this._scale, center.y * this._scale, radius * this._scale);
    };

    DebugDraw.prototype.DrawPolygon = function(vertices, vertexCount, color) {
      var v, v0, _i, _len, _ref;

      this._graphics.lineStyle(this._line_width, color.color);
      this._graphics.alpha = this._alpha;
      v0 = vertices[0];
      this._graphics.moveTo(v0.x * this._scale, v0.y * this._scale);
      _ref = vertices.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        this._graphics.lineTo(v.x * this._scale, v.y * this._scale);
      }
      return this._graphics.lineTo(v0.x * this._scale, v0.y * this._scale);
    };

    DebugDraw.prototype.DrawSegment = function(p1, p2, color) {
      this._graphics.lineStyle(this._line_width, color.color);
      this._graphics.alpha = this._alpha;
      this._graphics.moveTo(p1.x * this._scale, p1.y * this._scale);
      return this._graphics.lineTo(p2.x * this._scale, p2.y * this._scale);
    };

    DebugDraw.prototype.DrawSolidCircle = function(center, radius, axis, color) {
      var edge;

      this._graphics.beginFill(color.color);
      this._graphics.fillAlpha = this._fill_alpha;
      this.DrawCircle(center, radius, color);
      this._graphics.endFill();
      axis.Normalize();
      axis.Multiply(radius);
      edge = center.Copy();
      edge.Add(axis);
      return this.DrawSegment(center, edge, color);
    };

    DebugDraw.prototype.DrawSolidPolygon = function(vertices, vertexCount, color) {
      this._graphics.beginFill(color.color);
      this._graphics.fillAlpha = this._fill_alpha;
      this.DrawPolygon(vertices, vertexCount, color);
      return this._graphics.endFill();
    };

    DebugDraw.prototype.GetAlpha = function() {
      return this._alpha;
    };

    DebugDraw.prototype.GetDrawScale = function() {
      return this._scale;
    };

    DebugDraw.prototype.GetFillAlpha = function() {
      return this._fill_alpha;
    };

    DebugDraw.prototype.GetLineThickness = function() {
      return this._line_width;
    };

    DebugDraw.prototype.SetAlpha = function(_alpha) {
      this._alpha = _alpha;
    };

    DebugDraw.prototype.SetDrawScale = function(_scale) {
      this._scale = _scale;
    };

    DebugDraw.prototype.SetLineThickness = function(_line_width) {
      this._line_width = _line_width;
    };

    return DebugDraw;

  })(b2Dynamics.b2DebugDraw);

  ParticleSystem = (function() {
    function ParticleSystem(max_particles, update_fn, draw_fn) {
      this.max_particles = max_particles;
      this.update_fn = update_fn;
      this.draw_fn = draw_fn;
      this.particles = [];
      this.emitters = [];
      this.fields = [];
    }

    ParticleSystem.prototype.update = function() {
      var e, p, _i, _j, _len, _len1, _ref, _ref1, _results;

      _ref = this.emitters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e = _ref[_i];
        this._emit(e);
      }
      _ref1 = this.particles;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        p = _ref1[_j];
        _results.push(this._updateParticle(p));
      }
      return _results;
    };

    ParticleSystem.prototype.draw = function() {
      var p, _i, _len, _ref, _results;

      _ref = this.particles;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(this.draw_fn(p));
      }
      return _results;
    };

    ParticleSystem.prototype.addEmitter = function(emitter) {
      return this.emitters.push(emitter);
    };

    ParticleSystem.prototype.addField = function(field) {
      return this.fields.push(field);
    };

    ParticleSystem.prototype.removeEmitter = function(emitter) {
      return this.emitters = this.emitters.filter(function(e) {
        return e !== emitter;
      });
    };

    ParticleSystem.prototype.removeField = function(field) {
      return this.fields = this.fields.filter(function(f) {
        return f !== field;
      });
    };

    ParticleSystem.prototype._addParticle = function(particle) {
      if (this.particles.length < this.max_particles) {
        return this.particles.push(particle);
      }
    };

    ParticleSystem.prototype._emit = function(e) {
      var i, _i, _ref, _results;

      if (!e.active) {
        return;
      }
      _results = [];
      for (i = _i = 0, _ref = e.rate; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(this._addParticle(e.particle_fn()));
      }
      return _results;
    };

    ParticleSystem.prototype._updateParticle = function(p) {
      var dir_x, dir_y, f, field_acl, force, _i, _len, _ref;

      field_acl = {
        x: 0,
        y: 0
      };
      _ref = this.fields;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        dir_x = f.pos.x - p.pos.x;
        dir_y = f.pos.y - p.pos.y;
        force = f.strength / Math.pow(dir_x * dir_x + dir_y * dir_y, 1.5);
        field_acl.x += dir_x * force;
        field_acl.y += dir_y * force;
      }
      this.update_fn(p, field_acl);
      p.life--;
      if (p.life <= 0) {
        return this.particles = this.particles.filter(function(par) {
          return par !== p;
        });
      }
    };

    return ParticleSystem;

  })();

  $(function() {
    var DOM_LOADED;

    DOM_LOADED = true;
    return main();
  });

  W = 0;

  H = 0;

  main = function() {
    var attract_field, basic_emitter, basic_updater, black, blurHandler, body, bodyDef, canvas, circle_drawer, clear, clickHandler, container, cpr, createCircle, debugDraw, draw, event_catcher, explosion, fill_type, fixDef, focusHandler, graphics, h, i, jackie, jackie_tx, keyDownListener, main_loop, mouseDownHandler, mouseMoveHandler, mouseOutHandler, mouseUpHandler, mouseWheelHandler, onBeforeUnload, onResize, poly, ps, queue, r, renderer, result, shape, solution, stage, swctx, t_x, t_y, terrain, triangles, type, update, v, w, world, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m;

    W = settings.FULL_SCREEN ? window.innerWidth : settings.WIDTH;
    H = settings.FULL_SCREEN ? window.innerHeight : settings.HEIGHT;
    body = $('body');
    container = $('<div>');
    body.append(container);
    black = 0x000000;
    stage = new PIXI.Stage(black);
    renderer = PIXI.autoDetectRenderer(W, H);
    container.append(renderer.view);
    canvas = $('canvas')[0];
    graphics = new PIXI.Graphics();
    stage.addChild(graphics);
    jackie_tx = PIXI.Texture.fromImage("assets/img/jackie.png");
    jackie = new PIXI.Sprite(jackie_tx);
    jackie.rotation = .56;
    jackie.position.x = W / 2 - 16;
    jackie.position.y = H / 4 - 38;
    stage.addChild(jackie);
    basic_updater = function(p, field_acl) {
      p.vel.x += field_acl.x + p.acl.x;
      p.vel.y += field_acl.y + p.acl.y;
      p.pos.x += p.vel.x;
      return p.pos.y += p.vel.y;
    };
    circle_drawer = function(p) {
      graphics.alpha = .5;
      graphics.lineStyle(3, 0x00FFFF);
      return graphics.drawCircle(p.pos.x, p.pos.y, 7 * Math.random());
    };
    basic_emitter = {
      pos: {
        x: W / 2,
        y: H / 4
      },
      rate: 5,
      active: true,
      particle_fn: function() {
        var a, ax, ay, m, p, vx, vy;

        m = 6;
        a = 3.8;
        ax = Math.cos(a);
        ay = Math.sin(a);
        vx = -m * ax;
        vy = -m * ay;
        return p = {
          pos: {
            x: W / 2,
            y: H / 4 + Math.random() * 10 - 5
          },
          vel: {
            x: vx,
            y: vy
          },
          acl: {
            x: 0,
            y: 0
          },
          life: 50
        };
      }
    };
    attract_field = {
      pos: {
        x: W / 2 + 175,
        y: H / 2 - 40
      },
      strength: -100
    };
    ps = new ParticleSystem(500, basic_updater, circle_drawer);
    ps.addEmitter(basic_emitter);
    ps.addField(attract_field);
    createCircle = function(precision, origin, radius) {
      var angle, circleArray, i, v, _i;

      angle = 2 * Math.PI / precision;
      circleArray = [];
      for (i = _i = 0; 0 <= precision ? _i < precision : _i > precision; i = 0 <= precision ? ++_i : --_i) {
        v = {
          X: origin.x + radius * Math.cos(angle * i),
          Y: origin.y + radius * Math.sin(angle * i)
        };
        circleArray.push(v);
      }
      return [circleArray];
    };
    t_x = W / 2 / 30;
    t_y = 12;
    w = 10;
    h = 1;
    terrain = [
      [
        {
          X: t_x - w,
          Y: t_y - h
        }, {
          X: t_x + w,
          Y: t_y - h
        }, {
          X: t_x + w,
          Y: t_y + h
        }, {
          X: t_x - w,
          Y: t_y + h
        }
      ]
    ];
    explosion = createCircle(10, {
      x: t_x + 5,
      y: t_y - .5
    }, 1.4);
    ClipperLib.JS.ScaleUpPaths(terrain, 100);
    ClipperLib.JS.ScaleUpPaths(explosion, 100);
    cpr = new ClipperLib.Clipper();
    cpr.AddPaths(terrain, ClipperLib.PolyType.ptSubject, true);
    cpr.AddPaths(explosion, ClipperLib.PolyType.ptClip, true);
    solution = [];
    type = ClipperLib.ClipType.ctDifference;
    fill_type = ClipperLib.PolyFillType.pftNonZero;
    cpr.Execute(type, solution, fill_type, fill_type);
    solution = ClipperLib.JS.Clean(solution, .1 * 100);
    ClipperLib.JS.ScaleDownPaths(solution, 100);
    ClipperLib.JS.ScaleDownPaths(explosion, 100);
    result = [];
    for (_i = 0, _len = solution.length; _i < _len; _i++) {
      poly = solution[_i];
      r = [];
      for (_j = 0, _len1 = poly.length; _j < _len1; _j++) {
        v = poly[_j];
        r.push({
          x: v.X,
          y: v.Y
        });
      }
      swctx = new poly2tri.SweepContext(r);
      swctx.triangulate();
      triangles = swctx.getTriangles();
      triangles.forEach(function(t) {
        var tri;

        tri = [];
        t.getPoints().forEach(function(p) {
          return tri.push({
            x: p.x,
            y: p.y
          });
        });
        return result.push(tri);
      });
    }
    world = new b2Dynamics.b2World(new b2Math.b2Vec2(0, 10), true);
    fixDef = new b2Dynamics.b2FixtureDef();
    fixDef.density = 1.0;
    fixDef.friction = 0.5;
    fixDef.restitution = 0.2;
    bodyDef = new b2Dynamics.b2BodyDef();
    bodyDef.type = b2Dynamics.b2Body.b2_staticBody;
    for (_k = 0, _len2 = result.length; _k < _len2; _k++) {
      poly = result[_k];
      fixDef.shape = new b2Shapes.b2PolygonShape();
      shape = [];
      for (_l = 0, _len3 = poly.length; _l < _len3; _l++) {
        v = poly[_l];
        shape.push(new b2Math.b2Vec2(v.x, v.y));
      }
      fixDef.shape.SetAsArray(shape, shape.length);
      world.CreateBody(bodyDef).CreateFixture(fixDef);
    }
    bodyDef.type = b2Dynamics.b2Body.b2_dynamicBody;
    for (i = _m = 0; _m <= 10; i = ++_m) {
      if (Math.random() > 0.5) {
        fixDef.shape = new b2Shapes.b2PolygonShape();
        fixDef.shape.SetAsBox(Math.random() + 0.1, Math.random() + 0.1);
      } else {
        fixDef.shape = new b2Collision.Shapes.b2CircleShape(Math.random() + 0.1);
      }
      bodyDef.position.x = Math.random() * 10 + W / 2 / 30 - 5;
      bodyDef.position.y = Math.random() * 10;
      world.CreateBody(bodyDef).CreateFixture(fixDef);
    }
    if (settings.DEBUG) {
      debugDraw = new DebugDraw();
      debugDraw.SetSprite(graphics);
      debugDraw.SetDrawScale(30.0);
      debugDraw.SetFillAlpha(0.3);
      debugDraw.SetLineThickness(1.0);
      debugDraw.SetFlags(b2Dynamics.b2DebugDraw.e_shapeBit | b2Dynamics.b2DebugDraw.e_jointBit);
      world.SetDebugDraw(debugDraw);
    }
    onResize = function() {
      return console.log("resize");
    };
    keyDownListener = function(e) {
      return console.log("key:", e.keyCode);
    };
    onBeforeUnload = function(e) {
      return console.log("leaving");
    };
    mouseMoveHandler = function(e) {
      var x, y;

      x = e.clientX;
      y = e.clientY;
      return console.log("mouse:", x, y);
    };
    clickHandler = function(e) {
      var x, y;

      x = e.clientX;
      y = e.clientY;
      return console.log("click:", x, y);
    };
    mouseDownHandler = function(e) {
      return console.log("mouse down");
    };
    mouseUpHandler = function(e) {
      return console.log("mouse up");
    };
    mouseOutHandler = function(e) {
      return console.log("mouse out");
    };
    mouseWheelHandler = function(e) {
      var delta;

      delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));
      return console.log("mouse wheel: ", delta);
    };
    focusHandler = function(e) {
      return console.log("focus");
    };
    blurHandler = function(e) {
      return console.log("blur");
    };
    event_catcher = canvas;
    window.onresize = onResize;
    document.body.addEventListener('keydown', keyDownListener, false);
    window.onbeforeunload = onBeforeUnload;
    event_catcher.addEventListener('mousemove', mouseMoveHandler, false);
    event_catcher.addEventListener('click', clickHandler, false);
    event_catcher.addEventListener('mousedown', mouseDownHandler, false);
    event_catcher.addEventListener('mouseup', mouseUpHandler, false);
    event_catcher.addEventListener('mouseout', mouseOutHandler, false);
    event_catcher.addEventListener('DOMMouseScroll', mouseWheelHandler, false);
    event_catcher.addEventListener('mousewheel', mouseWheelHandler, false);
    event_catcher.addEventListener('focus', focusHandler, false);
    event_catcher.addEventListener('blur', blurHandler, false);
    main_loop = function() {
      update();
      clear();
      draw();
      return queue();
    };
    update = function() {
      world.Step(1 / 60, 10, 10);
      world.ClearForces();
      return ps.update();
    };
    clear = function() {
      return graphics.clear();
    };
    draw = function() {
      var v0, _len4, _n, _ref;

      if (settings.DEBUG) {
        world.DrawDebugData();
      }
      ps.draw();
      graphics.lineStyle(1, 0x00FF00);
      graphics.drawCircle(attract_field.pos.x, attract_field.pos.y, 5);
      graphics.lineStyle(2, 0xFF0000);
      v0 = explosion[0][0];
      graphics.moveTo(v0.X, v0.Y);
      _ref = explosion[0].slice(1);
      for (_n = 0, _len4 = _ref.length; _n < _len4; _n++) {
        v = _ref[_n];
        graphics.lineTo(v.X, v.Y);
      }
      graphics.lineTo(v0.X, v0.Y);
      return renderer.render(stage);
    };
    queue = function() {
      return window.requestAnimationFrame(main_loop);
    };
    return main_loop();
  };

}).call(this);
