// Generated by CoffeeScript 1.6.2
(function() {
  var DebugDraw, b2Collision, b2Common, b2Contacts, b2Controllers, b2Dynamics, b2Joints, b2Math, b2Shapes, main, settings;

  settings = {
    DEBUG: true,
    FULL_SCREEN: true,
    WIDTH: 700,
    HEIGHT: 500
  };

  b2Common = Box2D.Common;

  b2Math = Box2D.Common.Math;

  b2Collision = Box2D.Collision;

  b2Shapes = Box2D.Collision.Shapes;

  b2Dynamics = Box2D.Dynamics;

  b2Contacts = Box2D.Dynamics.Contacts;

  b2Controllers = Box2D.Dynamics.Controllers;

  b2Joints = Box2D.Dynamics.Joints;

  DebugDraw = (function() {
    function DebugDraw() {
      this._line_width = 1;
      this._alpha = 0.5;
      this._fill_alpha = 0.5;
      this._scale = 1.0;
      this.m_sprite = {
        graphics: {
          clear: function() {}
        }
      };
    }

    DebugDraw.prototype.SetSprite = function(_graphics) {
      this._graphics = _graphics;
    };

    DebugDraw.prototype.GetSprite = function() {
      return this._graphics;
    };

    DebugDraw.prototype.DrawCircle = function(center, radius, color) {
      this._graphics.alpha = this._alpha;
      this._graphics.lineStyle(this._line_width, color.color);
      return this._graphics.drawCircle(center.x * this._scale, center.y * this._scale, radius * this._scale);
    };

    DebugDraw.prototype.DrawPolygon = function(vertices, vertexCount, color) {
      var v, v0, _i, _len, _ref;

      this._graphics.lineStyle(this._line_width, color.color);
      this._graphics.alpha = this._alpha;
      v0 = vertices[0];
      this._graphics.moveTo(v0.x * this._scale, v0.y * this._scale);
      _ref = vertices.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        this._graphics.lineTo(v.x * this._scale, v.y * this._scale);
      }
      return this._graphics.lineTo(v0.x * this._scale, v0.y * this._scale);
    };

    DebugDraw.prototype.DrawSegment = function(p1, p2, color) {
      this._graphics.lineStyle(this._line_width, color.color);
      this._graphics.alpha = this._alpha;
      this._graphics.moveTo(p1.x * this._scale, p1.y * this._scale);
      return this._graphics.lineTo(p2.x * this._scale, p2.y * this._scale);
    };

    DebugDraw.prototype.DrawSolidCircle = function(center, radius, axis, color) {
      var edge;

      this._graphics.beginFill(color.color);
      this._graphics.fillAlpha = this._fill_alpha;
      this.DrawCircle(center, radius, color);
      this._graphics.endFill();
      axis.Normalize();
      axis.Multiply(radius);
      edge = center.Copy();
      edge.Add(axis);
      return this.DrawSegment(center, edge, color);
    };

    DebugDraw.prototype.DrawSolidPolygon = function(vertices, vertexCount, color) {
      this._graphics.beginFill(color.color);
      this._graphics.fillAlpha = this._fill_alpha;
      this.DrawPolygon(vertices, vertexCount, color);
      return this._graphics.endFill();
    };

    DebugDraw.prototype.GetAlpha = function() {
      return this._alpha;
    };

    DebugDraw.prototype.GetDrawScale = function() {
      return this._scale;
    };

    DebugDraw.prototype.GetFillAlpha = function() {
      return this._fill_alpha;
    };

    DebugDraw.prototype.GetLineThickness = function() {
      return this._line_width;
    };

    DebugDraw.prototype.SetAlpha = function(_alpha) {
      this._alpha = _alpha;
    };

    DebugDraw.prototype.SetDrawScale = function(_scale) {
      this._scale = _scale;
    };

    DebugDraw.prototype.SetLineThickness = function(_line_width) {
      this._line_width = _line_width;
    };

    return DebugDraw;

  })();

  $(function() {
    var DOM_LOADED;

    DOM_LOADED = true;
    return main();
  });

  main = function() {
    var black, blurHandler, body, bodyDef, canvas, clear, clickHandler, container, debugDraw, draw, event_catcher, fixDef, focusHandler, graphics, h, i, keyDownListener, main_loop, mouseDownHandler, mouseMoveHandler, mouseOutHandler, mouseUpHandler, mouseWheelHandler, onBeforeUnload, onResize, queue, renderer, s, stage, update, w, world, _i;

    w = settings.FULL_SCREEN ? window.innerWidth : settings.WIDTH;
    h = settings.FULL_SCREEN ? window.innerHeight : settings.HEIGHT;
    body = $('body');
    container = $('<div>');
    body.append(container);
    black = 0x000000;
    stage = new PIXI.Stage(black);
    renderer = PIXI.autoDetectRenderer(w, h);
    container.append(renderer.view);
    canvas = $('canvas')[0];
    graphics = new PIXI.Graphics();
    stage.addChild(graphics);
    world = new b2Dynamics.b2World(new b2Math.b2Vec2(0, 10), true);
    fixDef = new b2Dynamics.b2FixtureDef();
    fixDef.density = 1.0;
    fixDef.friction = 0.5;
    fixDef.restitution = 0.2;
    bodyDef = new b2Dynamics.b2BodyDef();
    bodyDef.type = b2Dynamics.b2Body.b2_staticBody;
    bodyDef.position.x = w / 2 / 30;
    bodyDef.position.y = 13;
    fixDef.shape = new b2Shapes.b2PolygonShape();
    s = fixDef.shape;
    s.SetAsBox(10, 1);
    world.CreateBody(bodyDef).CreateFixture(fixDef);
    bodyDef.type = b2Dynamics.b2Body.b2_dynamicBody;
    for (i = _i = 0; _i <= 10; i = ++_i) {
      if (Math.random() > 0.5) {
        fixDef.shape = new b2Shapes.b2PolygonShape();
        fixDef.shape.SetAsBox(Math.random() + 0.1, Math.random() + 0.1);
      } else {
        fixDef.shape = new b2Collision.Shapes.b2CircleShape(Math.random() + 0.1);
      }
      bodyDef.position.x = Math.random() * 10 + w / 2 / 30 - 5;
      bodyDef.position.y = Math.random() * 10;
      world.CreateBody(bodyDef).CreateFixture(fixDef);
    }
    if (settings.DEBUG) {
      debugDraw = new DebugDraw();
      debugDraw.SetSprite(graphics);
      debugDraw.SetDrawScale(30.0);
      debugDraw.SetFillAlpha(0.3);
      debugDraw.SetLineThickness(1.0);
      debugDraw.SetFlags(b2Dynamics.b2DebugDraw.e_shapeBit | b2Dynamics.b2DebugDraw.e_jointBit);
      world.SetDebugDraw(debugDraw);
    }
    onResize = function() {
      return console.log("resize");
    };
    keyDownListener = function(e) {
      return console.log("key:", e.keyCode);
    };
    onBeforeUnload = function(e) {
      return console.log("leaving");
    };
    mouseMoveHandler = function(e) {
      var x, y;

      x = e.clientX;
      y = e.clientY;
      return console.log("mouse:", x, y);
    };
    clickHandler = function(e) {
      var x, y;

      x = e.clientX;
      y = e.clientY;
      return console.log("click:", x, y);
    };
    mouseDownHandler = function(e) {
      return console.log("mouse down");
    };
    mouseUpHandler = function(e) {
      return console.log("mouse up");
    };
    mouseOutHandler = function(e) {
      return console.log("mouse out");
    };
    mouseWheelHandler = function(e) {
      var delta;

      delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));
      return console.log("mouse wheel: ", delta);
    };
    focusHandler = function(e) {
      return console.log("focus");
    };
    blurHandler = function(e) {
      return console.log("blur");
    };
    event_catcher = canvas;
    window.onresize = onResize;
    document.body.addEventListener('keydown', keyDownListener, false);
    window.onbeforeunload = onBeforeUnload;
    event_catcher.addEventListener('mousemove', mouseMoveHandler, false);
    event_catcher.addEventListener('click', clickHandler, false);
    event_catcher.addEventListener('mousedown', mouseDownHandler, false);
    event_catcher.addEventListener('mouseup', mouseUpHandler, false);
    event_catcher.addEventListener('mouseout', mouseOutHandler, false);
    event_catcher.addEventListener('DOMMouseScroll', mouseWheelHandler, false);
    event_catcher.addEventListener('mousewheel', mouseWheelHandler, false);
    event_catcher.addEventListener('focus', focusHandler, false);
    event_catcher.addEventListener('blur', blurHandler, false);
    main_loop = function() {
      update();
      clear();
      draw();
      return queue();
    };
    update = function() {
      world.Step(1 / 60, 10, 10);
      return world.ClearForces();
    };
    clear = function() {
      return graphics.clear();
    };
    draw = function() {
      if (settings.DEBUG) {
        world.DrawDebugData();
      }
      return renderer.render(stage);
    };
    queue = function() {
      return window.requestAnimationFrame(main_loop);
    };
    return main_loop();
  };

}).call(this);
